# Final Report
### Dom Polochak
### dp121@zips.uakron.edu

# Comparison
The obvious difference between `Jenkins` and `CircleCi` is the ease of use. `CircleCi` requires very little knowledge of `Docker` to use. As long as you have a `Dockerfile` or even if you find a good public image that someone else made you can build with `CircleCi`. Also, it's designed to integrate with `github` very well with every push it automatically runs so you can get quick feedback without having to build and compile the project locally, but this has some cons as well. `CircleCi` runs automatically after each commit where `Jenkins` requires you to manually run the build. This is a downside of `CircleCi`, it can be very inefficient because while developing you don't want to build for each little change and it will add a lot of builds to your workflow that don't accurately reflect the status of your project. You might be able to get around this buy using a dedicated branch but in general `Jenkins` gives you more control over when you want to build and your workflow in general. With `CircleCi` you can share your workflow with team members simply with a link. The natural down side to `CircleCi` SAAS design is you can't get as much information into what is happening internally and you have to trust that `CircleCi` is running as it's supposed to (which isn't always the case). Nevertheless `CircleCi` gives a the console output of the build and for the average project this is likely sufficient for debugging.   
On the other hand, `Jenkins` requires a really good understanding of `Docker` to use effectively. First, you need to run a `Docker` command to get `Jenkins` to start. Then any commands you want to run have to be in the `groovy` syntax as opposed to `yaml` in `CircleCi` which more widely used. All of this only allows you to run your build inside of the pre-set `Jenkins` image. If you want to use a custom image you have to set up DOOD which requires mounting the docker socket to `Jenkins` and then you have to give `Jenkins` permissions to the socket which, at least for me, changed my docker daemon permissions locally. Also you have to install all of the necessary plugins for `Docker`. Next, the pipeline commands only run inside of the `Jenkins` container so you have to switch all of the commands to `sh` commands to run them inside the custom container. Also, our current `Jenkins` setup runs on local host so if you want to share it between a team you have to host `Jenkins` on a server which requires another layer of technical knowledge.  
Overall, both programs have more or less the same functionality with `CircleCi` being much easier to implement especially for a small team that doesn't want to spend a significant amount of time learning the inner-workings of `Docker`, the downside being less control and slightly longer build times.  

# My Features
## Jenkinsfile
In class to edit your pipeline you have to either type it directly into the window in the configuration or you have to copy and paste the contents of your `.gy` file to that window and apply it. This isn't very user friendly, however there is a way to use source control with your pipeline commands through the use of a `Jenkinsfile`. To implement this put your pipeline code in a file called `Jenkinsfile` (there's an extension available in VS Code) and add it to the repository for your project. Then, go into your `Jenkins` project, go to configure, down to pipeline, and there's a drop down box for "definition" change it from `Pipeline Script` to `Pipeline Script from SCM` and then select git and add the link to your repository and you can even specify a specific branch to use. Now all you have to do is make your changes in your `Jenkinsfile` and push it to the git repository and when you click `Build Now` the changes should be reflected in the build. Using source control for the pipeline makes it a lot easier to keep track of changes and it saves the tedious step of having to manually copy and paste your pipeline every time. 
## xUnit
`xUnit` is a `Jenkins` plugin that gives you extra information about the tests in your code. If you change the `ctest` command to `ctest -T test --no-compress` it will write the test results to an xml file in `build/Testing/`. Then, you must archive the xml output file and run `xUnit` to process the file. After it's implemented it adds some really nice UI to your `Jenkins` dashboard. On the project window it gives you a graph of the test result trends over time that shows how many passed, failed or skipped. Inside the individual build on the left column of tools there's a new one called "Test Results" which will show what tests passed or failed for that specific build. This feature makes it a lot easier to see your test results because you don't have to comb through the console output to see the result of the tests. Also, with this implemented if a test fails the whole build will fail as opposed to without it it will still say it built successfully regardless of the test results. There is a similar testing feature in `CircleCi` but it currently only supports `Java` and `Python`  not `C++` so I wasn't able to implement it.
