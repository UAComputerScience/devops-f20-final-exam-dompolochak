# Final Report
### Dom Polochak
### dp121@zips.uakron.edu

# Comparison
The obvious difference between `Jenkins` and `CircleCi` is the ease of use. `CircleCi` requires very little knowledge of `Docker` to use. As long as you have a `Dockerfile` or even if you find a good public image that someone else made you can build with `CircleCi`. Also, it's designed to integrate with `github` very well with every push it automatically runs so you can get quick feedback without having to build and compile the project locally. Also, you can share your workflow with team members simply with a link. However, the natural down side to it's SAAS design is you can't get as much information into what is happening internally and you have to trust that `CircleCi` is running as it's supposed to. Nevertheless `CircleCi` gives a the console output of the build and for the average project this is likely sufficient for debugging.    
On the other hand, `Jenkins` requires a really good understanding of `Docker` to use effectively. First, you need to run a `Docker` command to get `Jenkins` to start. Then any commands you want to run have to be in the `groovy` syntax as opposed to `yaml` in `CircleCi` which more widely used. All of this only allows you to run your build inside of the pre-set `Jenkins` image. If you want to use a custom image you have to set up DOOD which requires mounting the docker socket to `Jenkins` and then you have to give `Jenkins` permissions to the socket which, at least for me, changed my docker daemon permissions locally. Next, the pipeline commands only run inside of the `jenkins` container so you have to switch all of the commands to `sh` commands to run them inside the custom container. Also, our current `Jenkins` setup runs on local host so if you want to share it between a team you have to host `Jenkins` on a server which requires another layer of technical knowledge.  
Overall, both programs have more or less the same functionality with `CircleCi` being much easier to implement especially for a small team that doesn't want to spend a significant amount of time learning the inner-workings of `Docker`. 